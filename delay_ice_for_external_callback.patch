diff --git a/liblinphone/include/linphone/api/c-nat-policy.h b/liblinphone/include/linphone/api/c-nat-policy.h
index f72acba9d..137abe242 100644
--- a/liblinphone/include/linphone/api/c-nat-policy.h
+++ b/liblinphone/include/linphone/api/c-nat-policy.h
@@ -289,6 +289,30 @@ LINPHONE_PUBLIC bool_t linphone_nat_policy_tls_turn_transport_enabled(const Linp
  */
 LINPHONE_PUBLIC LinphoneCore *linphone_nat_policy_get_core(const LinphoneNatPolicy *policy);
 
+// TN patch
+
+/**
+ * Tells whether the delay ICE feature is enabled.
+ * @param policy #LinphoneNatPolicy object @notnil
+ * @return Boolean value telling whether the delay ICE feature is enabled.
+ */
+bool_t linphone_nat_policy_delay_ice_for_external_callback_enabled(const LinphoneNatPolicy *policy);
+
+/**
+ * Tells whether the delay ICE feature is enabled.
+ * @param policy #LinphoneNatPolicy object @notnil
+ * @param enable Boolean value telling whether the delay ICE feature is enabled.
+ */
+void linphone_nat_policy_enable_delay_ice_for_external_callback(LinphoneNatPolicy *policy, bool_t enable);
+
+typedef void (*BasicFunc)();
+typedef void (*FuncTakingFunc)(BasicFunc);
+
+FuncTakingFunc linphone_get_delay_ice_external_callback();
+void linphone_set_delay_ice_external_callback(FuncTakingFunc func);
+
+// TN patch
+
 /**
  * @}
  */
diff --git a/liblinphone/src/c-wrapper/api/c-nat-policy.cpp b/liblinphone/src/c-wrapper/api/c-nat-policy.cpp
index 10b1b48dd..161c3e6ed 100644
--- a/liblinphone/src/c-wrapper/api/c-nat-policy.cpp
+++ b/liblinphone/src/c-wrapper/api/c-nat-policy.cpp
@@ -167,3 +167,23 @@ const char * linphone_nat_policy_get_nat_v6_address(const LinphoneNatPolicy *pol
 void linphone_nat_policy_set_nat_v6_address(LinphoneNatPolicy *policy, const char *v6_address){
 	NatPolicy::toCpp(policy)->setNatV6Address(L_C_TO_STRING(v6_address));
 }
+
+// TN patch
+bool_t linphone_nat_policy_delay_ice_for_external_callback_enabled(const LinphoneNatPolicy *policy) {
+	return NatPolicy::toCpp(policy)->delayIceEnabled() ? TRUE : FALSE;
+}
+
+void linphone_nat_policy_enable_delay_ice_for_external_callback(LinphoneNatPolicy *policy, bool_t enable){
+	NatPolicy::toCpp(policy)->enableDelayIce(!!enable);
+}
+
+static FuncTakingFunc delay_ice_external_callback = NULL;
+
+FuncTakingFunc linphone_get_delay_ice_external_callback() {
+    return delay_ice_external_callback;
+}
+
+void linphone_set_delay_ice_external_callback(FuncTakingFunc func){
+    delay_ice_external_callback = func;
+}
+// TN patch
diff --git a/liblinphone/src/conference/session/media-session-p.h b/liblinphone/src/conference/session/media-session-p.h
index c9a82b889..0fff069b8 100644
--- a/liblinphone/src/conference/session/media-session-p.h
+++ b/liblinphone/src/conference/session/media-session-p.h
@@ -271,6 +271,11 @@ private:
 	LinphoneNatPolicy *natPolicy = nullptr;
 	std::unique_ptr<StunClient> stunClient;
 
+	// TN patch
+	static std::queue<std::function<LinphoneStatus()>> iceDeferedPrepareTasks;
+	static void runIcePrepareTasks();
+	// TN patch
+
 	std::queue<std::function<LinphoneStatus()>> iceDeferedGatheringTasks;
 	std::queue<std::function<LinphoneStatus()>> iceDeferedCompletionTasks;
 
diff --git a/liblinphone/src/conference/session/media-session.cpp b/liblinphone/src/conference/session/media-session.cpp
index fce30a5bc..f45667299 100644
--- a/liblinphone/src/conference/session/media-session.cpp
+++ b/liblinphone/src/conference/session/media-session.cpp
@@ -241,6 +241,7 @@ void MediaSessionPrivate::accepted() {
 				makeLocalMediaDescription(op->getRemoteMediaDescription() ? localIsOfferer : true,
 										  q->isCapabilityNegotiationEnabled(), false);
 			}
+
 			/*
 			 * If ICE is enabled, we'll have to do the prepare() step, however since defering the sending of the ACK is
 			 * complicated and confusing from a signaling standpoint, ICE we will skip the STUN gathering by not giving
@@ -2784,6 +2785,18 @@ void MediaSessionPrivate::freeResources() {
 	getStreamsGroup().finish();
 }
 
+// TN patch
+std::queue<std::function<LinphoneStatus()>> MediaSessionPrivate::iceDeferedPrepareTasks;
+
+void MediaSessionPrivate::runIcePrepareTasks() {
+	while (!iceDeferedPrepareTasks.empty()) {
+		const auto task = iceDeferedPrepareTasks.front();
+		task(); // Ok to discard result?
+		iceDeferedPrepareTasks.pop();
+	}
+}
+// TN patch
+
 void MediaSessionPrivate::queueIceCompletionTask(const std::function<LinphoneStatus()> &lambda) {
 	iceDeferedCompletionTasks.push(lambda);
 }
@@ -3651,6 +3664,7 @@ LinphoneStatus MediaSessionPrivate::accept(const MediaSessionParams *msp, BCTBX_
 		updateLocalMediaDescriptionFromIce(op->getRemoteMediaDescription() == nullptr);
 		return startAccept();
 	};
+
 	if (linphone_nat_policy_ice_enabled(natPolicy) && getStreamsGroup().prepare()) {
 		queueIceGatheringTask(acceptCompletionTask);
 		return 0; /* Deferred until completion of ICE gathering */
@@ -3723,10 +3737,39 @@ void MediaSessionPrivate::reinviteToRecoverFromConnectionLoss() {
 	L_Q();
 	lInfo() << "MediaSession [" << q
 			<< "] is going to be updated (reINVITE) in order to recover from lost connectivity";
+
+	// TN patch
+	auto deferredTask = [this]() -> LinphoneStatus {
+
+	L_Q();
+	lInfo() << "MediaSessionPrivate::reinviteToRecoverFromConnectionLoss() -> deferredTask()";
+
+	const LinphoneNatPolicy *natPolicy = linphone_core_get_nat_policy(q->getCore()->getCCore());
+
+	if (natPolicy) {
+		LinphoneNatPolicy *newNatPolicy = linphone_nat_policy_clone(natPolicy);
+		q->setNatPolicy(newNatPolicy);
+		linphone_nat_policy_unref(newNatPolicy);
+	}
+
 	selectOutgoingIpVersion();
 	getStreamsGroup().getIceService().resetSession();
 	MediaSessionParams newParams(*getParams());
 	q->update(&newParams, CallSession::UpdateMethod::Invite, q->isCapabilityNegotiationEnabled());
+
+	return 0;
+	};
+
+	lInfo() << "MediaSessionPrivate::reinviteToRecoverFromConnectionLoss() -> linphone_nat_policy_delay_ice_for_external_callback_enabled=" << (int)linphone_nat_policy_delay_ice_for_external_callback_enabled(natPolicy);
+
+	if (linphone_nat_policy_delay_ice_for_external_callback_enabled(natPolicy)) {
+		MediaSessionPrivate::iceDeferedPrepareTasks.push(deferredTask);
+		const auto callback = linphone_get_delay_ice_external_callback();
+		callback(&MediaSessionPrivate::runIcePrepareTasks);
+	} else {
+		deferredTask();
+	}
+	// TN patch
 }
 
 void MediaSessionPrivate::repairByInviteWithReplaces() {
@@ -4453,6 +4496,7 @@ int MediaSession::startInvite(const Address *destination, const string &subject,
 		if (d->localDesc && (d->localDesc->streams.size() > 0) && (d->localDesc->streams[0].getMaxRate() > 0))
 			ms_snd_card_set_preferred_sample_rate(getCore()->getCCore()->sound_conf.play_sndcard,
 												  d->localDesc->streams[0].getMaxRate());
+
 		d->getStreamsGroup().prepare();
 	}
 
@@ -4629,6 +4673,8 @@ LinphoneStatus MediaSession::update(const MediaSessionParams *msp, const UpdateM
 			return res;
 		};
 
+		lInfo() << "MediaSessionPrivate::update() -> ice=" << (int)linphone_nat_policy_ice_enabled(d->natPolicy) << ", turn=" << (int)linphone_nat_policy_turn_enabled(d->natPolicy) << ", tcp_turn=" << (int)linphone_nat_policy_tcp_turn_transport_enabled(d->natPolicy);
+
 		const auto preparingStreams = d->getStreamsGroup().prepare();
 		// reINVITE sent after full state must be sent after ICE negotiations are completed if ICE is enabled
 		if (linphone_nat_policy_ice_enabled(d->natPolicy) && preparingStreams) {
diff --git a/liblinphone/src/nat/ice-service.cpp b/liblinphone/src/nat/ice-service.cpp
index 6e02de334..027cf4c07 100644
--- a/liblinphone/src/nat/ice-service.cpp
+++ b/liblinphone/src/nat/ice-service.cpp
@@ -251,6 +251,8 @@ LinphoneCore *IceService::getCCore()const{
 }
 
 int IceService::gatherLocalCandidates(){
+	lInfo() << "IceService::gatherLocalCandidates()";
+
 	list<string> localAddrs = IfAddrs::fetchLocalAddresses();
 	bool ipv6Allowed = linphone_core_ipv6_enabled(getCCore());
 	const auto & mediaLocalIp = getMediaSessionPrivate().getMediaLocalIp();
@@ -327,10 +329,14 @@ void IceService::addPredefinedSflrxCandidates(const NatPolicy *natPolicy){
  * -1: no gathering started and something went wrong with local candidates. There is no way to start the ICE session.
  */
 int IceService::gatherIceCandidates () {
+
 	const struct addrinfo *ai = nullptr;
 	int err = 0;
 	
 	LinphoneNatPolicy *cNatPolicy = getMediaSessionPrivate().getNatPolicy();
+
+	lInfo() << "IceService::gatherIceCandidates() -> ice=" << (int)linphone_nat_policy_ice_enabled(cNatPolicy) << ", turn=" << (int)linphone_nat_policy_turn_enabled(cNatPolicy) << ", tcp_turn=" << (int)linphone_nat_policy_tcp_turn_transport_enabled(cNatPolicy);
+
 	NatPolicy *natPolicy =  cNatPolicy ? NatPolicy::toCpp(cNatPolicy) : nullptr;
 	if (natPolicy && natPolicy->stunServerActivated()) {
 		ai = natPolicy->getStunServerAddrinfo();
diff --git a/liblinphone/src/nat/nat-policy.cpp b/liblinphone/src/nat/nat-policy.cpp
index 275731bdb..f6cbdc53e 100644
--- a/liblinphone/src/nat/nat-policy.cpp
+++ b/liblinphone/src/nat/nat-policy.cpp
@@ -71,8 +71,9 @@ NatPolicy::NatPolicy(const NatPolicy &other): HybridObject<LinphoneNatPolicy, Na
 	mIceEnabled = other.mIceEnabled;
 	mUpnpEnabled = other.mUpnpEnabled;
 	mTurnUdpEnabled = other.mTurnUdpEnabled;
-	mTurnTcpEnabled = false;
-	mTurnTlsEnabled = false;
+	mTurnTcpEnabled = other.mTurnTcpEnabled;
+	mTurnTlsEnabled = other.mTurnTlsEnabled;
+	mDelayIceEnabled = other.mDelayIceEnabled;
 }
 
 NatPolicy::~NatPolicy(){
@@ -151,6 +152,7 @@ void NatPolicy::clear(){
 	mTurnUdpEnabled = false;
 	mTurnTcpEnabled = false;
 	mTurnTlsEnabled = false;
+	mDelayIceEnabled = false;
 }
 
 void NatPolicy::setStunServer(const std::string &stunServer){
diff --git a/liblinphone/src/nat/nat-policy.h b/liblinphone/src/nat/nat-policy.h
index 9a4180e76..dff92f802 100644
--- a/liblinphone/src/nat/nat-policy.h
+++ b/liblinphone/src/nat/nat-policy.h
@@ -76,6 +76,9 @@ public:
 	void setUserData(void *d){ mUserData = d ;}
 	void *getUserData()const{ return mUserData; }
 	
+	void enableDelayIce(bool enable) { mDelayIceEnabled = enable; }
+	bool delayIceEnabled() const { return mDelayIceEnabled; }
+	
 	const std::string &getRef()const{ return mRef; } 
 	
 	const struct addrinfo * getStunServerAddrinfo();
@@ -106,6 +109,7 @@ private:
 	bool mTurnUdpEnabled = false;
 	bool mTurnTcpEnabled = false;
 	bool mTurnTlsEnabled = false;
+	bool mDelayIceEnabled = false;
 };
 
 LINPHONE_END_NAMESPACE
diff --git a/mediastreamer2/src/voip/ice.c b/mediastreamer2/src/voip/ice.c
index d6b61d53..7419d357 100644
--- a/mediastreamer2/src/voip/ice.c
+++ b/mediastreamer2/src/voip/ice.c
@@ -996,8 +996,46 @@ static void ice_check_list_add_stun_server_request(IceCheckList *cl, IceStunServ
 	cl->stun_server_requests = bctbx_list_append(cl->stun_server_requests, request);
 }
 
+// TN patch
+static void clear_turn_state(RtpTransport *rtptp, MSTurnContext *context) {
+	if (!rtptp || !context) {
+		return;
+	}
+
+	if (context->turn_tcp_client) {
+		// TODO: Currently this code just nulls the ptr to the last TURN client but notably
+		// does NOT free the memory.
+		//
+		// This is because there is another thread also using the client to send RTP,
+		// so this is tricky to sync properly. Additionally just just trying _set_endpoint
+		// to null stop that thread leads to some one-way audio issues during the call,
+		// which does not seem easy to fix.
+		//
+		// However just nulling the ptr seems to work without issue, and allow reconnects
+		// still using ICE and TCP-TURN, but we leak memory :(
+		//
+		// This is the minimal code needed to stop the RTP and free the TURN client
+		// meta_rtp_transport_set_endpoint(rtptp, NULL);
+		// ms_turn_tcp_client_destroy(context->turn_tcp_client);
+
+		(void)rtptp;
+		context->turn_tcp_client = NULL;
+	}
+
+	// clear all TURN state to avoid stale nonce error
+#define FREE_AND_NULL_VAR(var) do { ms_free(var); var = NULL; } while (0)
+	FREE_AND_NULL_VAR(context->realm);
+	FREE_AND_NULL_VAR(context->nonce);
+	FREE_AND_NULL_VAR(context->username);
+	FREE_AND_NULL_VAR(context->password);
+	FREE_AND_NULL_VAR(context->ha1);
+}
+// TN patch
+
 static bool_t ice_check_list_gather_candidates(IceCheckList *cl, Session_Index *si)
 {
+	ms_debug("ice_check_list_gather_candidates()");
+
 	IceStunServerRequest *request;
 	RtpTransport *rtptp=NULL;
 	MSTimeSpec curtime = ice_current_time();
@@ -1008,15 +1046,20 @@ static bool_t ice_check_list_gather_candidates(IceCheckList *cl, Session_Index *
 		cl->gathering_candidates = TRUE;
 		cl->gathering_start_time = curtime;
 		rtp_session_get_transports(cl->rtp_session,&rtptp,NULL);
+
 		if (rtptp) {
+
 			struct sockaddr *sa = (struct sockaddr *)&cl->rtp_session->rtp.gs.loc_addr;
 			if (cl->session->turn_enabled) {
+				// TN patch - clear TURN state due to stale nonce and sockets
+				clear_turn_state(rtptp, cl->rtp_turn_context);
+
 				/* Define the RTP endpoint that will perform STUN encapsulation/decapsulation for TURN data */
 				meta_rtp_transport_set_endpoint(rtptp, ms_turn_context_create_endpoint(cl->rtp_turn_context));
 				ms_turn_context_set_server_addr(cl->rtp_turn_context, (struct sockaddr *)&cl->session->ss, cl->session->ss_len);
 
-				// Start turn tcp client now if needed
-				if (cl->rtp_turn_context->transport != MS_TURN_CONTEXT_TRANSPORT_UDP) {
+				// TN patch - we always use TCP when TURN is enabled
+				{
 					if (!cl->rtp_turn_context->turn_tcp_client) {
 						cl->rtp_turn_context->turn_tcp_client = ms_turn_tcp_client_new(cl->rtp_turn_context,
 							cl->rtp_turn_context->transport == MS_TURN_CONTEXT_TRANSPORT_TLS,
@@ -1049,12 +1092,15 @@ static bool_t ice_check_list_gather_candidates(IceCheckList *cl, Session_Index *
 		if (!rtp_session_rtcp_mux_enabled(cl->rtp_session) && rtptp) {
 			struct sockaddr *sa = (struct sockaddr *)&cl->rtp_session->rtcp.gs.loc_addr;
 			if (cl->session->turn_enabled) {
+				// TN patch - clear TURN state due to stale nonce and sockets
+				clear_turn_state(rtptp, cl->rtcp_turn_context);
+
 				/* Define the RTP endpoint that will perform STUN encapsulation/decapsulation for TURN data */
 				meta_rtp_transport_set_endpoint(rtptp, ms_turn_context_create_endpoint(cl->rtcp_turn_context));
 				ms_turn_context_set_server_addr(cl->rtcp_turn_context, (struct sockaddr *)&cl->session->ss, cl->session->ss_len);
 
-				// Start turn tcp client now if needed
-				if (cl->rtcp_turn_context->transport != MS_TURN_CONTEXT_TRANSPORT_UDP) {
+				// TN patch - we always use TCP when TURN is enabled
+				{
 					if (!cl->rtcp_turn_context->turn_tcp_client) {
 						cl->rtcp_turn_context->turn_tcp_client = ms_turn_tcp_client_new(cl->rtcp_turn_context,
 							cl->rtcp_turn_context->transport == MS_TURN_CONTEXT_TRANSPORT_TLS,
